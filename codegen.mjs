import { readdir, readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import shell from 'shelljs';
import {
    arbitrum,
    arbitrumSepolia,
    base,
    baseSepolia,
    cannon,
    mainnet,
    optimism,
    optimismSepolia,
    sepolia,
} from 'viem/chains';

//TODO: Not available yet on cannon.
const supportedMainnets = [arbitrum.id, base.id, mainnet.id, optimism.id];
const supportedTestnets = [
    arbitrumSepolia.id,
    baseSepolia.id,
    cannon.id,
    optimismSepolia.id,
    sepolia.id,
];
//TODO: evaluate to be a env-var. But it needs to sync with npm-deps.
const packageRef = 'cartesi-rollups:2.0.0-rc.17';
const abiFolder = join(process.cwd(), 'abi');
const outFolder = join(process.cwd(), 'src', 'deployments');
const codegenMetaFileName = '__meta.json';
const v2OutDir = join(
    process.cwd(),
    'node_modules',
    '@cartesi',
    'rollups-v2',
    'out',
);

const buildContractsOfInterest = (chainId) => [
    {
        name: 'CartesiApplication',
        targetFile: join(v2OutDir, 'Application.sol', 'Application.json'),
    },
    {
        name: 'CartesiApplicationFactory',
        targetFile: join(outFolder, chainId, 'ApplicationFactory.json'),
    },
    {
        name: 'InputBoxV2',
        targetFile: join(outFolder, chainId, 'InputBox.json'),
    },
];

const shouldSkipInspect = async ({ packageRef, targetFolder }) => {
    const meta = await readFile(join(targetFolder, codegenMetaFileName), {
        encoding: 'utf-8',
    })
        .then((fileContent) => {
            try {
                return JSON.parse(fileContent);
            } catch (error) {
                console.error(error);
            }
            return null;
        })
        .catch((_) => {
            return null;
        });

    const isPackageRefMatching = meta?.packageRef === packageRef;

    if (isPackageRefMatching)
        console.log(`Skipping Cannon inspect for package ${packageRef}`);

    return isPackageRefMatching;
};

const generateContractsJSON = async (sourceFolder, targetFolder) => {
    const files = await readdir(sourceFolder);
    const contracts = {};

    for (const file of files) {
        if (file === codegenMetaFileName) continue;

        const filePath = join(sourceFolder, file);
        const [name] = file.split('.');
        const content = await readFile(filePath);
        contracts[name] = JSON.parse(content);
    }

    await writeFile(
        join(targetFolder, 'contracts.json'),
        JSON.stringify({ contracts }, null, ' '),
        { encoding: 'utf-8' },
    );
};

const execCannonInspect = async ({ packageRef, chainId, outFolder }) => {
    const targetFolder = join(outFolder, chainId);

    const shouldSkip = await shouldSkipInspect({ packageRef, targetFolder });

    if (shouldSkip) return { ok: true };

    const child = shell.exec(
        `npm run cannon -- inspect ${packageRef} --chain-id ${chainId} --write-deployments ${targetFolder} --quiet`,
        { async: true },
    );

    const outputPromise = new Promise((resolve) => {
        child.on('exit', (code) => {
            resolve({ code });
        });
    });

    const output = await outputPromise;

    const isSuccess = output.code === 0;

    if (isSuccess) {
        await Promise.all([
            generateContractsJSON(targetFolder, targetFolder),
            writeFile(
                join(targetFolder, codegenMetaFileName),
                JSON.stringify({
                    packageRef,
                    timestamp: Math.floor(Date.now() / 1000),
                    desc: 'Autogenerated. Do not change it manually.',
                }),
                { encoding: 'utf-8' },
            ),
        ]);
    }

    return { ok: isSuccess };
};

const readABIFor = async (list) => {
    const contracts = await Promise.all(
        list.map((target) => {
            return readFile(target.targetFile, {
                encoding: 'utf-8',
            }).then((content) => {
                try {
                    const config = JSON.parse(content);
                    return { name: target.name, abi: config.abi };
                } catch (error) {
                    console.error(error.message);
                    return { name: target.name, abi: [] };
                }
            });
        }),
    );

    return contracts;
};

/**
 *
 * @param {string} chainId
 * @returns {void}
 */
async function codegen(chainId) {
    const { ok } = await execCannonInspect({
        packageRef,
        chainId,
        outFolder,
    });

    if (!ok)
        return Promise.reject(
            `Failed during inspection of ${packageRef} for chain-id: ${chainId}`,
        );

    return { ok: true, chainId };
}

async function generateABIFiles(chainId) {
    const contracts = await readABIFor(
        buildContractsOfInterest(chainId.toString()),
    );

    const result = await Promise.allSettled(
        contracts.map((contract) => {
            const content = JSON.stringify(contract.abi, null, ' ');
            const fileName = join(abiFolder, `${contract.name}.json`);
            return writeFile(fileName, content, { encoding: 'utf-8' });
        }),
    );

    result.forEach((data, i) => {
        if (data.status === 'fulfilled')
            console.info(`${contracts[i].name} created at ${abiFolder}\n`);
        else
            console.error(
                `${contracts[i].name} failed to be created. Reason: ${data.reason}`,
            );
    });
}

async function run() {
    const networks = [...supportedTestnets];
    const codegenPromises = networks.map((chainId) => {
        console.log(`Codegen for chain-id: ${chainId.toString()}`);
        return codegen(chainId.toString());
    });
    const codegenResult = await Promise.allSettled(codegenPromises);

    const index = codegenResult.findIndex(
        (data) => data.status === 'fulfilled',
    );

    if (index >= 0) await generateABIFiles(networks[index]);

    codegenResult.forEach((data, i) => {
        if (data.status === 'fulfilled')
            console.info(
                `Rollups contracts for chain-id ${supportedTestnets[
                    i
                ].toString()} generated at ${outFolder}`,
            );
        else
            console.error(
                `Rollups contracts for chain-id ${supportedTestnets[
                    i
                ].toString()} failed to be created. Reason: ${data.reason}`,
            );
    });
}

run();
